package com.example.ecommerce.marketplace.application.product;

import com.example.ecommerce.marketplace.domain.product.Product;
import com.example.ecommerce.marketplace.domain.product.ProductVariant;
import com.example.ecommerce.marketplace.domain.product.PriceTier;
import com.example.ecommerce.marketplace.domain.product.ProductRepository;
import com.example.ecommerce.marketplace.domain.supplier.SupplierRepository;
import lombok.RequiredArgsConstructor;

import java.util.List;

/**
 * Use case for creating a new product in the marketplace.
 * Handles validation, uniqueness checks, and initial product setup.
 * Framework-agnostic, following Clean Architecture principles.
 */
@RequiredArgsConstructor
public class CreateProductUseCase {

    private final ProductRepository productRepository;
    private final SupplierRepository supplierRepository;

    /**
     * Executes the product creation use case.
     *
     * @param command the creation command containing product data
     * @return the result indicating success or failure with details
     */
    public CreateProductResult execute(CreateProductCommand command) {
        // 1. Validate required fields
        if (command.getSku() == null || command.getSku().trim().isEmpty()) {
            return CreateProductResult.failure("Product SKU is required", "INVALID_SKU");
        }
        if (command.getName() == null || command.getName().trim().isEmpty()) {
            return CreateProductResult.failure("Product name is required", "INVALID_NAME");
        }
        if (command.getBasePrice() == null) {
            return CreateProductResult.failure("Base price is required", "INVALID_PRICE");
        }
        if (command.getMinimumOrderQuantity() == null) {
            return CreateProductResult.failure("Minimum order quantity is required", "INVALID_MOQ");
        }
        if (command.getSupplierId() == null) {
            return CreateProductResult.failure("Supplier ID is required", "INVALID_SUPPLIER_ID");
        }

        // 2. Verify supplier exists
        if (!supplierRepository.findById(command.getSupplierId()).isPresent()) {
            return CreateProductResult.failure("Supplier not found", "SUPPLIER_NOT_FOUND");
        }

        // 3. Convert price tiers from DTOs to domain objects
        List<PriceTier> priceTiers = null;
        if (command.getPriceTiers() != null && !command.getPriceTiers().isEmpty()) {
            priceTiers = command.getPriceTiers().stream()
                .map(dto -> new PriceTier(
                    null, // ID will be generated by repository
                    dto.getMinQuantity(),
                    dto.getMaxQuantity(),
                    dto.getPricePerUnit(),
                    dto.getDiscountPercent()
                ))
                .toList();
        }

        // 4. Convert variants from DTOs to domain objects
        List<ProductVariant> variants = null;
        if (command.getVariants() != null && !command.getVariants().isEmpty()) {
            variants = command.getVariants().stream()
                .map(dto -> new ProductVariant(
                    null, // ID will be generated by repository
                    null, // productId will be set by repository
                    dto.getVariantSku(),
                    dto.getColor(),
                    dto.getSize(),
                    dto.getPriceAdjustment(),
                    dto.getImages()
                ))
                .toList();
        }

        // 5. Create product domain object
        Product product = new Product(
            null, // ID will be generated by repository
            command.getSku(),
            command.getName(),
            command.getDescription(),
            command.getCategoryId(),
            command.getSupplierId(),
            command.getBasePrice(),
            command.getMinimumOrderQuantity(),
            "piece", // Default unit
            command.getImages(),
            variants,
            priceTiers,
            null, // Created at will be set by repository
            null  // Updated at will be set by repository
        );

        // 6. Validate SKU format using domain logic
        if (!product.validateSku()) {
            return CreateProductResult.failure(
                "Invalid SKU format (alphanumeric and hyphens only, max 50 characters)",
                "INVALID_SKU_FORMAT"
            );
        }

        // 5. Validate name format using domain logic
        if (!product.validateName()) {
            return CreateProductResult.failure(
                "Invalid product name (minimum 3 characters, maximum 200 characters)",
                "INVALID_NAME_FORMAT"
            );
        }

        // 6. Validate base price using domain logic
        if (!product.validatePrice()) {
            return CreateProductResult.failure(
                "Invalid base price (must be greater than 0)",
                "INVALID_BASE_PRICE"
            );
        }

        // 7. Validate minimum order quantity using domain logic
        if (!product.validateMinimumOrderQuantity()) {
            return CreateProductResult.failure(
                "Invalid minimum order quantity (must be at least 1)",
                "INVALID_MOQ_VALUE"
            );
        }

        // 8. Check SKU uniqueness
        if (productRepository.existsBySku(command.getSku())) {
            return CreateProductResult.failure("SKU already exists", "SKU_EXISTS");
        }

        // 9. Save product
        Product savedProduct = productRepository.save(product);

        // 10. Return success result
        return CreateProductResult.success(savedProduct.getId());
    }
}
