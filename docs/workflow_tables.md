## Error Handling Strategy
1. **Input Validation Errors**: Return HTTP 400 Bad Request with detailed error messages specifying which fields are invalid and why.
2. **Authentication Errors**: Return HTTP 401 Unauthorized for invalid credentials or missing authentication tokens (e.g., JWT).
3. **Authorization Errors**: Return HTTP 403 Forbidden when a user attempts to access resources they do not have permissions for (e.g., a retailer trying to access supplier-only endpoints).
4. **Resource Not Found Errors**: Return HTTP 404 Not Found when requested resources (e.g., supplier, retailer, product) do not exist.
5. **Conflict Errors**: Return HTTP 409 Conflict when attempting to create resources that violate unique constraints (e.g., duplicate email or SKU).
6. **Server Errors**: Return HTTP 500 Internal Server Error for unexpected server-side issues, along with logging the error details for further investigation.

## Onboarding & Setup Flows

This section details the registration process for both suppliers and retailers, as well as the initial product catalog setup.

### Supplier Registration Flow

| Step | Initiator | Action (Message) | Receiver | API Triggers/Actions | Database Interaction | Requirements |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | User/Client (Supplier) | Submit registration form | System | POST /api/supplier/register | Create new supplier record (with default constructor), mandatory fields: **email, password** | - Validate email format, if invalid, throws **400** <br> - Validate password strength, if invalid, throws **400** <br> - Check for existing email, if found, throws **409** <br> - Hash password before storing |
| 2 | System | Registration successful notification | User/Client (Supplier) | POST /api/suppliers/{supplier_id}/notify_registration | Create notification record | - Include supplier ID in notification |
| 3 | User/Client (Supplier) | Upload business documents | System | POST /api/suppliers/{supplier_id}/upload_documents | Update supplier record | - Validate document types and sizes, if invalid, throws **400** |
| 4 | System | Authenticate supplier | User/Client (Supplier) | POST /api/suppliers/{supplier_id}/authenticate | Update "isVerified" status in supplier record | - Ensure the documents contains the **name, business license number, phone, address**, if invalid, throws **400** <br> - Check for existing business license number, if found, throws **409** <br> - Update **name, businessLicense, phone, address** fields <br> - Set "isVerified" to true upon successful verification |

### Retailer Registration Flow

| Step | Initiator | Action (Message) | Receiver | API Triggers/Actions | Database Interaction | Requirements |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | User/Client (Retailer) | Submit registration form | System | POST /api/retailer/register | Create new retailer record (with default constructor), mandatory fields: **email, password** | - Validate email format, if invalid, throws **400** <br> - Validate password strength, if invalid, throws **400** <br> - Check for existing email, if found, throws **409** <br> - Hash password before storing |
| 2 | System | Registration successful notification | User/Client (Retailer) | POST /api/retailers/{retailer_id}/notify_registration | Create notification record | - Include retailer ID in notification |
| 3 | User/Client (Retailer) | Upload business documents | System | POST /api/retailers/{retailer_id}/upload_documents | Update retailer record | - Validate document types and sizes, if invalid, throws **400** |
| 4 | System | Authenticate retailer | User/Client (Retailer) | POST /api/retailers/{retailer_id}/authenticate | Update "isVerified" status in retailer record | - Ensure the documents contains the **name, business license number, phone, address**, if invalid, throws **400** <br> - Check for existing business license number, if found, throws **409** <br> - Update **name, businessLicense, phone, address** fields <br> - Set "isVerified" to true upon successful verification |

## Product Registration Flow
| Step | Initiator | Action (Message) | Receiver | API Triggers/Actions | Database Interaction | Requirements |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | Supplier | Register new product (via UI form submission) | System | `POST /api/products/register` | *(See Step 2)* | - Must be authenticated as a **Supplier**. If not, throws **401 Unauthorized**. <br> - Payload must contain: `productName`, `categoryIDs`, and `option` ("Yes" or "No"). <br> - **If `option` == "No"**: Payload must also contain `sku`, `basePrice`, `finalPrice`, and **`availableQuantity`** for the single variant. <br> - **If `option` == "Yes"**: Payload must contain an array of `variants` (at least one), and *each* variant object must contain **`availableQuantity`**. |
| 2 | System | Process registration request | Database | (Backend logic for `POST /api/products/register`) | **Start Transaction** <br><br> 1. Get `supplierID` from the authentication token. <br><br> 2. `INSERT` into `Product` table (with `productName`, etc.). Get back `new_pID`. <br><br> 3. **Check the `option` flag:** <br>      **IF `option` == "No"**: <br>          `INSERT` into `ProductVariant` (set `productID = new_pID`, `variantName = productName`, `sku`, etc.). Get back `new_vID`. <br>          **`INSERT` into `Inventory` (set `supplierID`, `variantID = new_vID`, `availableQuantity` from payload, and `status` based on quantity).** <br><br>      **ELSE (`option` == "Yes")**: <br>          `FOR EACH` variant in `variants` array: <br>              `INSERT` into `ProductVariant` (set `productID = new_pID`, details from variant). Get back `new_vID`. <br>              **`INSERT` into `Inventory` (set `supplierID`, `variantID = new_vID`, `availableQuantity` from variant object, and `status` based on quantity).** <br><br> 4. **Commit Transaction** | - The entire operation must be **atomic**. If *any* insert (Product, Variant, or Inventory) fails, the entire transaction must be rolled back. <br> - **Input Validation**: <br>      - If `availableQuantity` is missing or not a non-negative integer, throws **400 Bad Request**. <br>      - If `variants` array is empty (when `option` == "Yes"), throws **400 Bad Request**. <br> - **Conflict Check**: <br>      - If any `sku` already exists, the DB constraint will fire, throw **409 Conflict**, and roll back the transaction. |
| 3 | System | Send confirmation or error | Supplier | `HTTP 201 Created` (on success) <br> `HTTP 400/401/403/409/500` (on error) | None | - On success, return the new `Product` object, including its nested `ProductVariant`(s) and their new `Inventory` records. <br> - On error, return a clear message (e.g., "SKU already exists," "availableQuantity must be a number"). |

### Product Update Flow (Changing "No Variants" to "Has Variants")

| Step | Initiator | Action (Message) | Receiver | API Triggers/Actions | Database Interaction | Requirements |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | Supplier | Clicks "Edit" on a product in the management page. | System | `GET /api/products/{pID}` | `SELECT * FROM Product WHERE pID = ...` <br> `SELECT * FROM ProductVariant WHERE productID = ...` <br> **`SELECT * FROM Inventory WHERE variantID IN (...)`** | - Must be authenticated as the **Supplier** who owns the product. If not, throws **401/403**. <br> - System retrieves the product, its single "dummy" variant, and its associated inventory record to populate the edit form. |
| 2 | Supplier | 1. Toggles "Does this product have variants?" to **"Yes"**. <br> 2. Edits `productName` (e.g., "Paracetamol 500mg" -\> "Paracetamol"). <br> 3. Edits the *existing* variant's `variantName`, `sku`, etc. <br> 4. Clicks "Add Variant" and adds new variants (e.g., "250mg Tablets"), **providing `sku`, `basePrice`, `finalPrice`, and `availableQuantity` for each**. <br> 5. Clicks "Save". | System | `PUT /api/products/{pID}` | *(See Step 3)* | - The `PUT` payload must contain the updated `productName` AND the *full list* of all variants (the updated original one + any new ones). <br> - The original variant's `vID` must be included. <br> - Each **new** variant in the list must have `availableQuantity`. <br> - If `availableQuantity` is missing or invalid for a new variant, throws **400 Bad Request**. |
| 3 | System | Process product update | Database | (Backend logic for `PUT /api/products/{pID}`) | **Start Transaction** <br><br> 1. Get `supplierID` from auth token. <br><br> 2. `UPDATE Product` table (set `productName`, `updatedAt`, etc. for `{pID}`). <br><br> 3. `FOR EACH` variant in `variants` array from payload: <br>      **IF `vID` is provided** (and matches an existing variant): <br>          `UPDATE ProductVariant` (set `variantName`, `sku`, etc. for that `vID`). <br>          **(Optional) `UPDATE Inventory` if `availableQuantity` was part of the payload for this variant.** <br><br>      **ELSE (`vID` is null/missing)**: <br>          `INSERT` into `ProductVariant` (this is a new variant, set `productID = pID`). Get back `new_vID`. <br>          **`INSERT` into `Inventory` (set `supplierID`, `variantID = new_vID`, `availableQuantity` from variant object, and `status`).** <br><br> 4. **Commit Transaction** | - The entire operation must be **atomic**. If any `INSERT` or `UPDATE` fails (e.g., **409 Conflict** on a new `sku`), the transaction must be rolled back. <br> - **Validation**: Must check `availableQuantity` is a non-negative integer for all **new** variants. Throws **400 Bad Request** if not. <br> - (Note) This logic assumes inventory `availableQuantity` for the *original* variant is updated via a separate `POST /api/inventory/stock` endpoint, not this product edit form. If you *do* want to update it here, the `UPDATE Inventory` step is required. |
| 4 | System | Send confirmation or error | Supplier | `HTTP 200 OK` (on success) <br> `HTTP 400/401/403/409/500` (on error) | None | Return the fully updated `Product` object with its new list of `ProductVariant`(s) and their associated `Inventory` data. |

## Order Management Flows

### Order Placement Flow

| Step | Initiator | Action (Message) | Receiver | API Triggers/Actions | Database Interaction | Requirements |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | User/Client (Retailer) | Submit new order (e.g., from "cart" checkout) | System | `POST /api/orders` | *(See Step 2)* | - Must be authenticated as a **Retailer**. If not, throws **401 Unauthorized**. <br> - Request body must contain: `supplierID`, `shippingAddress`, and an `items` array. <br> - **Input Validation**: <br>      - If `supplierID` or `shippingAddress` is missing, throws **400 Bad Request**. <br>      - If `items` array is missing or empty, throws **400 Bad Request** ("Order must contain at least one item"). <br>      - For each item, if `variantID` or `quantity` is missing, or if `quantity` is not a positive integer, throws **400 Bad Request**. |
| 2 | System | Process new order submission | Database | (Backend logic for `POST /api/orders`) | **Start Transaction** <br><br> 1. Get `retailerID` from auth token. <br> 2. Initialize `calculatedTotalAmount = 0.0`. <br> 3. Create a temporary list `orderItemsToCreate`. <br><br> 4. **`FOR EACH` item in `items` array:** <br>      a. `SELECT finalPrice FROM ProductVariant WHERE vID = item.variantID`. <br>          - If variant not found, **Rollback** and throw **404 Not Found** ("Variant {id} not found"). <br>          - Store this `unitPrice`. <br>      b. `SELECT availableQuantity, reservedQuantity FROM Inventory WHERE variantID = item.variantID AND supplierID = payload.supplierID`. <br>          - If record not found, **Rollback** and throw **404 Not Found** ("Item {id} is not stocked by this supplier"). <br>          - Calculate `currentAvailableStock = availableQuantity - reservedQuantity`. <br>          - **`IF item.quantity > currentAvailableStock`**: <br>              - **Rollback** and throw **409 Conflict** ("Insufficient stock for {variantName}"). <br>      c. Calculate `itemTotalPrice = unitPrice * item.quantity`. <br>      d. Add `itemTotalPrice` to `calculatedTotalAmount`. <br>      e. Add `{ variantID, quantity, unitPrice, itemTotalPrice }` to `orderItemsToCreate` list. <br><br> 5. **`INSERT` into `Order`** table (set `retailerID`, `supplierID`, `totalAmount = calculatedTotalAmount`, `shippingAddress`, `status = 'PENDING'`). Get back `new_oID`. <br><br> 6. **`FOR EACH` item in `orderItemsToCreate` list:** <br>      a. **`INSERT` into `OrderItem`** (set `orderID = new_oID`, `variantID`, `quantity`, `unitPrice`, `finalTotalPrice`). <br><br> 7. **`FOR EACH` item in `items` array:** <br>      a. **`UPDATE Inventory`** SET `reservedQuantity = reservedQuantity + item.quantity` WHERE `variantID = item.variantID` AND `supplierID = payload.supplierID`. <br><br> 8. **Commit Transaction** | - The entire operation must be **atomic**. Any failure (e.g., one item out of stock) must roll back the entire transaction. <br> - The system *must* lock the `Inventory` rows being checked to prevent race conditions (e.g., using `SELECT ... FOR UPDATE`). |
| 3 | System | Send confirmation or error | User/Client (Retailer) | `HTTP 201 Created` (on success) <br> `HTTP 400/401/403/404/409/500` (on error) | None | - On success, return the newly created `Order` object, including its nested `OrderItem`(s). <br> - On error (e.CSS, "Insufficient stock"), return the specific, clear error message. |

### Order Status Management Flow
| Step | Initiator | Action (Message) | Receiver | API Triggers/Actions | Database Interaction | Requirements |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | User/Client (Supplier) | Update order status (e.g., "Confirm" or "Ship") | System | `PATCH /api/orders/{oID}/status` | *(See Step 2)* | - Must be authenticated as a **Supplier**. If not, throws **401 Unauthorized**. <br> - Request body must contain the new `status` (e.g., `CONFIRMED`, `SHIPPED`). <br> - If `status` is missing or not a valid enum value, throws **400 Bad Request**. |
| 2 | System | Process status update | Database | (Backend logic for `PATCH .../status`) | 1. `SELECT * FROM Order WHERE oID = {oID}`. <br> 2. **Authorize**: If `order.supplierID != auth.supplierID`, throw **403 Forbidden**. <br> 3. **Validate State**: Check if transition is valid (e.g., `PENDING` -\> `CONFIRMED`, `CONFIRMED` -\> `SHIPPED`). If invalid (e.g., `PENDING` -\> `SHIPPED`), throw **400 Bad Request** ("Cannot ship an unconfirmed order"). <br><br> 4. **`IF newStatus == 'SHIPPED'`**: <br>      - **Start Transaction** <br>      - `SELECT * FROM OrderItem WHERE orderID = {oID}`. <br>      - `FOR EACH item IN OrderItems`: <br>          - `UPDATE Inventory SET availableQuantity = availableQuantity - item.quantity, reservedQuantity = reservedQuantity - item.quantity WHERE variantID = item.variantID`. <br>      - `UPDATE Order SET status = 'SHIPPED', expectedDeliveryDate = ... WHERE oID = {oID}`. <br>      - **Commit Transaction** <br><br> 5. **`ELSE` (for `CONFIRMED`, `PROCESSING`, etc.)**: <br>      - `UPDATE Order SET status = newStatus WHERE oID = {oID}`. | - The `SHIPPED` transition **must** be atomic. If any inventory update fails, the entire transaction (including the order status change) must be **rolled back**. <br> - The `reservedQuantity` and `availableQuantity` are decremented *at the same time* when shipping. |
| 3 | System | Send confirmation | User/Client (Supplier) | `HTTP 200 OK` | None | - Return the updated `Order` object. |

### Order Cancellation Flow
| Step | Initiator | Action (Message) | Receiver | API Triggers/Actions | Database Interaction | Requirements |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | User/Client (Retailer or Supplier) | Request to cancel the order | System | `PATCH /api/orders/{oID}/status` | *(See Step 2)* | - Must be authenticated (**401**). <br> - Request body must be `{"status": "CANCELLED"}`. |
| 2 | System | Process cancellation | Database | (Backend logic for `PATCH .../status`) | **Start Transaction** <br><br> 1. `SELECT * FROM Order WHERE oID = {oID}`. <br> 2. **Authorize**: If `auth.userID != order.retailerID` AND `auth.userID != order.supplierID`, throw **403 Forbidden**. <br> 3. **Validate State**: If `order.status` is `SHIPPED` or `DELIVERED`, throw **400 Bad Request** ("Cannot cancel an order that has already been shipped"). <br><br> 4. `UPDATE Order SET status = 'CANCELLED' WHERE oID = {oID}`. <br><br> 5. `SELECT * FROM OrderItem WHERE orderID = {oID}`. <br><br> 6. `FOR EACH item IN OrderItems`: <br>      - **`UPDATE Inventory SET reservedQuantity = reservedQuantity - item.quantity WHERE variantID = item.variantID`**. <br><br> 7. **Commit Transaction** | - This transaction must be **atomic**. <br> - This action *releases* the reserved stock, making it available for other orders. It does *not* change `availableQuantity`. |
| 3 | System | Send confirmation | User/Client (Retailer or Supplier) | `HTTP 200 OK` | None | - Return the updated `Order` (now with `status: CANCELLED`). |

### Delivery Confirmation Flow

| Step | Initiator | Action (Message) | Receiver | API Triggers/Actions | Database Interaction | Requirements |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | User/Client (Retailer) | Confirm order has been received | System | `PATCH /api/orders/{oID}/status` | *(See Step 2)* | - Must be authenticated as a **Retailer**. If not, **401/403**. <br> - Request body must be `{"status": "DELIVERED"}`. |
| 2 | System | Process delivery confirmation | Database | (Backend logic for `PATCH .../status`) | 1. `SELECT * FROM Order WHERE oID = {oID}`. <br> 2. **Authorize**: If `auth.userID != order.retailerID`, throw **403 Forbidden**. <br> 3. **Validate State**: If `order.status != 'SHIPPED'`, throw **400 Bad Request** ("Cannot confirm delivery for an order that has not been shipped"). <br><br> 4. `UPDATE Order SET status = 'DELIVERED', actualDeliveryDate = CURRENT_TIMESTAMP WHERE oID = {oID}`. | - This is a simple `UPDATE` and does not require a complex transaction. |
| 3 | System | Send confirmation | User/Client (Retailer) | `HTTP 200 OK` | None | - Return the final, updated `Order` object. |

### List & Get Order Details Flow
| Step | Initiator | Action (Message) | Receiver | API Triggers/Actions | Database Interaction | Requirements |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | User/Client (Retailer or Supplier) | Request to see order history | System | `GET /api/orders` | 1. Get `userID` and `role` from auth token. <br> 2. **`IF role == 'RETAILER'`**: <br>      - `SELECT * FROM Order WHERE retailerID = userID` <br> 3. **`ELSE IF role == 'SUPPLIER'`**: <br>      - `SELECT * FROM Order WHERE supplierID = userID` | - Must be authenticated (**401**). <br> - Should support filtering by status (e.g., `?status=PENDING`). <br> - Should support pagination (e.g., `?page=1&limit=20`). |
| 2 | User/Client (Retailer or Supplier) | Request to see a single order's details | System | `GET /api/orders/{oID}` | 1. `SELECT * FROM Order WHERE oID = {oID}`. <br> 2. If not found, throw **404 Not Found**. <br> 3. **Authorize**: If `auth.userID != order.retailerID` AND `auth.userID != order.supplierID`, throw **403 Forbidden**. <br> 4. `SELECT * FROM OrderItem WHERE orderID = {oID}`. | - Must return the `Order` object along with a nested array of its `OrderItems`. |
| 3 | System | Return order data | User/Client (Retailer or Supplier) | `HTTP 200 OK` | None | - Return the JSON payload of the requested order(s). |

## Quotation Management Flows

### Quotation Request Flow
| Step | Initiator | Action (Message) | Receiver | API Triggers/Actions | Database Interaction | Requirements |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | Retailer | Create quotation request | System | POST /api/v1/quotations/requests | Create new quotation request record | - Validate retailer ID not null, if null, throws **400** <br> - Validate supplier ID not null, if null, throws **400** <br> - Check retailer exists, if not found, throws **404** <br> - Check supplier exists, if not found, throws **404** <br> - Validate request items not empty, if empty, throws **400** <br> - For each item: validate product ID exists, if not found, throws **404** <br> - For each item: validate quantity > 0, if not, throws **400** <br> - Validate validUntil date is in future, if past date, throws **400** <br> - Generate unique request number <br> - Set initial status to DRAFT |
| 2 | System | Quotation request notification | Supplier | POST /api/v1/quotations/requests/{request_id}/notify | Create notification record | - Validate request ID exists, if not found, throws **404** <br> - Check supplier notification preferences <br> - Create notification record for supplier <br> - Send notification via configured channels |

### Quotation Offer Flow
| Step | Initiator | Action (Message) | Receiver | API Triggers/Actions | Database Interaction | Requirements |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | Supplier | Submit quotation offer | System | POST /api/v1/quotations/offers | Create new quotation offer record | - Validate quotation request ID exists, if not found, throws **404** <br> - Check quotation request is not expired, if expired, throws **400** <br> - Validate supplier is the target supplier, if not, throws **403** <br> - Validate offer items not empty, if empty, throws **400** <br> - Check all offer items match request items, if mismatch, throws **400** <br> - For each item: validate quoted price > 0, if not, throws **400** <br> - Validate validUntil date is in future, if past date, throws **400** <br> - Calculate total amount <br> - Generate unique offer number <br> - Set status to SUBMITTED |
| 2 | System | Offer notification | Retailer | POST /api/v1/quotations/offers/{offer_id}/notify | Create notification record | - Validate offer ID exists, if not found, throws **404** <br> - Get retailer from quotation request <br> - Create notification record for retailer <br> - Send notification of new quotation offer |

### Quotation Decision Flow
| Step | Initiator | Action (Message) | Receiver | API Triggers/Actions | Database Interaction | Requirements |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | Retailer | Accept/Reject quotation offer | System | POST /api/v1/quotations/offers/{offer_id}/accept<br>POST /api/v1/quotations/offers/{offer_id}/reject | Update offer status | - Validate offer ID exists, if not found, throws **404** <br> - Check offer is not expired, if expired, throws **400** <br> - Validate retailer owns the original request, if not, throws **403** <br> - Check offer status is SUBMITTED, if not, throws **400** <br> - Update offer status to ACCEPTED/REJECTED <br> - Record decision timestamp and reason <br> - If ACCEPTED: optionally auto-create order from quotation |
| 2 | System | Decision notification | Supplier | POST /api/v1/quotations/offers/{offer_id}/decision_notify | Create notification record | - Validate offer exists with decision, if not found, throws **404** <br> - Get supplier from offer <br> - Create decision notification record <br> - Send notification of retailer's decision |

## Inventory Management Flows

### Inventory Restocking Flow
| Step | Initiator | Action (Message) | Receiver | API Triggers/Actions | Database Interaction | Requirements |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | Supplier | Restock inventory | System | POST /api/v1/products/{product_id}/inventory/restock | Update inventory available quantity | - Validate product ID exists, if not found, throws **404** <br> - Check supplier owns the product, if not, throws **403** <br> - Validate restock quantity > 0, if not, throws **400** <br> - Validate restock quantity <= maximum allowed (e.g., 1,000,000), if exceeded, throws **400** <br> - Check inventory record exists, if not found, throws **404** <br> - Add to available quantity <br> - Update last restocked timestamp <br> - Update inventory status to AVAILABLE if was OUT_OF_STOCK |
| 2 | System | Low stock check | System | GET /api/v1/inventory/low-stock | Query inventory below reorder level | - Query all inventory where availableQuantity <= reorderLevel <br> - Filter by supplier if parameter provided <br> - Generate reorder alerts for low stock items <br> - Return list of products needing restock |

<!-- ### Inventory Reservation/Release Flow
| Step | Initiator | Action (Message) | Receiver | API Triggers/Actions | Database Interaction | Requirements |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | System | Reserve inventory | System | POST /api/v1/products/{product_id}/inventory/reserve | Move quantity from available to reserved | - Validate product ID exists, if not found, throws **404** <br> - Check inventory record exists, if not found, throws **404** <br> - Validate quantity > 0, if not, throws **400** <br> - Check sufficient available quantity, if insufficient, throws **400** <br> - Validate inventory status is AVAILABLE, if not, throws **400** <br> - Reduce available quantity, increase reserved quantity <br> - Update last updated timestamp |
| 2 | System | Release reserved inventory | System | POST /api/v1/products/{product_id}/inventory/release | Move quantity from reserved to available | - Validate product ID exists, if not found, throws **404** <br> - Check inventory record exists, if not found, throws **404** <br> - Validate quantity > 0, if not, throws **400** <br> - Check sufficient reserved quantity exists, if insufficient, throws **400** <br> - Reduce reserved quantity, increase available quantity <br> - Update last updated timestamp |
| 3 | System | Deduct inventory | System | POST /api/v1/products/{product_id}/inventory/deduct | Remove quantity from reserved | - Validate product ID exists, if not found, throws **404** <br> - Check inventory record exists, if not found, throws **404** <br> - Validate quantity > 0, if not, throws **400** <br> - Check sufficient reserved quantity exists, if insufficient, throws **400** <br> - Reduce reserved quantity (order fulfilled) <br> - Update last updated timestamp <br> - Update inventory status to OUT_OF_STOCK if total quantity is 0 | -->
